<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<style>
  .headerlink {
    display: none;
  }
</style>
<title>JSX Tutorial</title>
</head>
<body>
<center>
<div id="body">
<div id="top">
<h1><a href="./">JSX</a></h1>
a faster, safer, easier alternative to JavaScript
</div>
<table id="menu">
<tr>
<td><a href="./">Top</a></td>
<td><a href="http://qb7.2ch.net/_403/" target="_blank">Try</a></td>
<td class="selected"><a href="tutorial.html">Tutorial</a></td>
<td><a href="https://github.com/jsx/jsx/">Download</a></td>
<td><a href="faq.html">FAQ</a></td>
</tr>
</table>
<div id="main">

<h2 id="background">Background</h2>

<p>
JSX is a statically-typed, object-oriented programming language compiling to standalone JavaScript. The reason why JSX was developed is our need for a more robust programming language than JavaScript.  However, JSX is fairly close to JavaScript especially in its statements and expressions.
</p>
<p>
Statically-typed programming language is robust because certain sorts of problems, for example typos in variable names or missing function definitions, are detected at compile-time. This is important especially in middle- to large-scale software development in which a number of engineers may be engaged.
</p>
<p>
Therefore, JSX is designed as a statically-typed language. All the values and variables have a static type and you can only assign a correctly-typed value to a variable. In addition, all the functions including closures have types which are determined by the types of parameters and the return values, where you cannot call a function with incorrectly typed arguments.
</p>
<p>
Also, another important reason why JSX was developed is to boost JavaScript performance. JavaScript itself is not so slow but large-scale development tends to have many abstraction layers, e.g. proxy classes and accessor methods, which often have negative impact on performance.  JSX boosts performance by <em>inline expansion</em>: function bodies are expanded to where they are being called, if the functions being called could be determined at compile-time. This is the power of the statically-typed language in terms of performance.
</p>

<h2 id="run-hello-world">Run "Hello, World!"</h2>

<p>
Let's start by running our first JSX program: <span class="pre">hello.jsx</span>.  We use the <span class="pre">jsx</span> command, which is the JSX compiler in the JSX distribution, to compile JSX source code to JavaScript.
</p>
<p>
Type as follows in the JSX distribution and/or repository, and then you will see it saying <span class="pre">"Hello, world!"</span>.
</p>
<pre>
$ bin/jsx --run example/hello.jsx
</pre>
<p>
We will look into the <span class="pre">hello.jsx</span> source code in the next section.
</p>

<h2 id="program-structure">Program Structure</h2>

<p>
Here is <span class="pre">hello.jsx</span>, the source code of the "Hello world!" example. You can see several features of JSX in this program, namely, static types and class structure within the source code.
</p>
<pre>
class _Main {
    static function main(args : string[]) : void {
        log "Hello, world!";
    }
}
</pre>
<p>
Class <span class="pre">_Main</span> has a static member function (a.k.a. a class method) named <span class="pre">main</span>, that takes an array of strings and returns nothing. <span class="pre">_Main.main(:string[]):void</span> is the entry point of JSX applications that is called when a user invokes an application from command line.  JSX, like Java, does not allow top-level statements or functions.
</p>
<p>
The <span class="pre">log</span> statement is mapped to <span class="pre">console.log()</span> in JavaScript, which displays the arguments to stdout with a newline.
</p>
<p>
Next, we look into another typical library class, <span class="pre">Point</span>:</p>
<pre>
class Point {
    var x = 0;
    var y = 0;

    function constructor() {
    }

    function constructor(x : number, y : number) {
        this.set(x, y);
    }

    function constructor(other : Point) {
        this.set(other);
    }

    function set(x : number, y : number) : void {
        this.x = x;
        this.y = y;
    }

    function set(other : Point) : void {
        this.x = other.x;
        this.y = other.y;
    }
}
</pre>
<p>
As you can see, member variables of Point, <span class="pre">var x</span> and <span class="pre">var y</span>, are declared without types, but their types are deducted from their initial values to be <span class="pre">number</span>.
</p>
<p>
You might be surprised at multiple definition of member functions: one takes no parameters and the others take parameters.  They are overloaded by their types of parameters.  When you construct the class with <span class="pre">new Point()</span>, the first constructor, which takes no parameters, is called. The second with two parameters will be called on <span class="pre">new Point(2, 3)</span> and the third with one parameter will be called as a copy constructor. Other forms of construction, e.g. <span class="pre">new Point(42)</span> or <span class="pre">new Point("foo", "bar")</span> will cause compilation errors of mismatching signatures. The <span class="pre">Point#set()</span> functions are also overloaded and the compiler know how to call the correct one.
</p>

<h2 id="static-types">Static Types</h2>
<p>
Basic type concept will be described in this section.  Primitive types, object types, variant type, and MayBeUndefined types exist in JSX.
</p>
<p>
Primitive types, e.g. <span class="pre">string</span>, <span class="pre">boolean</span>, or <span class="pre">number</span> are non-nullable, immutable types.
</p>
<pre>
var s : string = "hello";
var n : number = 42;
var b : boolean = true;
</pre>
<p>
Object types, e.g. <span class="pre">string[]</span> (array of string), functions or <span class="pre">Date</span>, are nullable, mutable types.</p>
<pre>
var d : Date = new Date(); // Date
var f : function():void = function() : void { log "Hi!"; };
var a : string[] = ["foo"]; // the same as Array.&lt;string&gt;
</pre>
<p>
Variant type, which means "no static type information," is used for interacting with existing JavaScript APIs.  Some JavaScript libraries may return a variant value, which type cannot be determined at compile time.  All you can do on variant values is to check equality of a variant value to another variant value. You have to cast it to another type before doing anything else on the value.
</p>
<p>
MayBeUndefined type is a meta type which indicates a value may be undefined.  For example, the return type of <span class="pre">Array.&lt;string&gt;#shift()</span> is <span class="pre">MayBeUndefined.&lt;string&gt;</span>. When you use a MayBeUndefined value, you have to make sure of the value is not undefined.</p>
<pre>
function shiftOrReturnEmptyString(args : string[]) : string {
    if (args.length > 0)
        return args.shift();
    else
        return "";
}
</pre>
<div class="note">
When the source code is compiled in debug mode (which is the default), the compiler will insert run-time type-checking code.  An exception will be raised (or the debugger will be activated) when misuse of an undefined value as actual value is detected.  Run-time type checks can be omitted by compiling the source code with the <span class="pre">--release</span> option.
</div>

<h2 id="modules">Modules</h2>

<p>
JSX has a module system. You can reuse JSX class libraries by the <span class="pre">import</span> statement. For example, the following program uses <span class="pre">timer.jsx</pre> module, which exports the <span class="pre">Timer</span> class.
</p>
<pre>
import "timer.jsx";

class _Main {

    static function main(args : string[]) : void {
        Timer.setTimeout(function() : void {
            log "Hello, world!";
        }, 1000);
    }

}
</pre>
<p>
A module may export multiple classes, but you can specify what modules you import or name a namespace which the module is imported into.
</p>

<h2 id="on-web-browsers">Interface to Web Browsers</h2>

<p>
The <span class="pre">js/web.jsx</span> module provides the interface to web browser APIs, e.g. the <span class="pre">window</pan> object and DOM APIs.  The example below shows how to insert a text node into an HTML.
</p>
<pre>
// hello.jsx
import "js/web.jsx";

class _Main {

    static function say() : void {
        var text = dom.window.document.createTextNode("Hello, world!");
        dom.getElementById("hello").appendChild(text);
    }

}
</pre>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;Hello, world!&lt;/title&gt;
    &lt;script src="hello.jsx.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        window.addEventListener("load", function(e) {
            JSX.require("hello.jsx").Hello.say$();
        });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;p id="hello"&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
Once you compile <span class="pre">hello.jsx</span> by the following command, then you can access the HTML and you will see it saying "Hello, world!."
</p>
<pre>
$ bin/jsx --output hello.jsx.js hello.jsx
</pre>

</div>
<div id="footer">
Copyright &copy; 2012 <a href="http://dena.jp/intl/">DeNA Co., Ltd.</a>
</div>
</center>
</body>
</html>
