<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<style>
  .headerlink {
    display: none;
  }
</style>
<title>JSX Tutorial</title>
</head>
<body>
<center>
<div id="body">
<div id="top">
<h1><a href="./">JSX</a></h1>
a faster, safer, easier alternative to JavaScript
</div>
<table id="menu">
<tr>
<td><a href="./">Top</a></td>
<td><a href="http://qb7.2ch.net/_403/" target="_blank">Try</a></td>
<td class="selected"><a href="tutorial.html">Tutorial</a></td>
<td><a href="https://github.com/jsx/jsx/">Download</a></td>
<td><a href="faq.html">FAQ</a></td>
</tr>
</table>
<div id="main">

<h2 id="background">Background</h2>

<p>
JSX is a statically-typed, object-oriented programming language compiling to standalone JavaScript. The reason why JSX was developed is our need for a more robust programming language than JavaScript.  However, JSX is fairly close to JavaScript especially in its statements and expressions.
</p>
<p>
Statically-typed programming language is robust because certain sorts of problems, for example typos in variable names or missing function definitions, are detected at compile-time. This is important especially in middle- to large-scale software development in which a number of engineers may be engaged.
</p>
<p>
Therefore, JSX is designed as a statically-typed language. All the values and variables have a static type and you can only assign a correctly-typed value to a variable. In addition, all the functions including closures have types which are determined by the types of parameters and the return values, where you cannot call a function with incorrectly typed arguments.
</p>
<p>
Also, another important reason why JSX was developed is to boost JavaScript performance. JavaScript itself is not so slow but large-scale development tends to have many abstraction layers, e.g. proxy classes and accessor methods, which often have negative impact on performance.  JSX boosts performance by <em>inline expansion</em>: function bodies are expanded to where they are being called, if the functions being called could be determined at compile-time. This is the power of the statically-typed language in terms of performance.
</p>

<h2 id="run-hello-world">Run "Hello, World!"</h2>

<p>
Let's start by running our first JSX program: <span class="pre">hello.jsx</span>.  We use the <span class="pre">jsx</span> command, which is the JSX compiler in the JSX distribution, to compile JSX source code to JavaScript.
</p>
<p>
Type as follows in the JSX distribution and/or repository, and then you will see it saying <span class="pre">"Hello, world!"</span>.
</p>
<pre>
$ bin/jsx --run example/hello.jsx
</pre>
<p>
We will look into the <span class="pre">hello.jsx</span> source code in the next section.
</p>

<h2 id="program-structure">Program Structure</h2>

<p>
Here is <span class="pre">hello.jsx</span>, the source code of the "Hello world!" example. You can see several features of JSX in this program, namely, static types and class structure within the source code.
</p>
<pre>
class _Main {
    static function main(args : string[]) : void {
        log "Hello, world!";
    }
}
</pre>
<p>
Class <span class="pre">_Main</span> has a static member function (a.k.a. a class method) named <span class="pre">main</span>, that takes an array of strings and returns nothing. <span class="pre">_Main.main(:string[]):void</span> is the entry point of JSX applications that is called when a user invokes an application from command line.  JSX, like Java, does not allow top-level statements or functions.
</p>
<p>
The <span class="pre">log</span> statement is mapped to <span class="pre">console.log()</span> in JavaScript, which displays the arguments to stdout with a newline.
</p>
<p>
Next, we look into another typical library class, <span class="pre">Point</span>:</p>
<pre>
class Point {
    var x = 0;
    var y = 0;

    function constructor() {
    }

    function constructor(x : number, y : number) {
        this.set(x, y);
    }

    function constructor(other : Point) {
        this.set(other);
    }

    function set(x : number, y : number) : void {
        this.x = x;
        this.y = y;
    }

    function set(other : Point) : void {
        this.x = other.x;
        this.y = other.y;
    }
}
</pre>
<p>
As you can see, member variables of Point, <span class="pre">var x</span> and <span class="pre">var y</span>, are declared without types, but their types are deducted from their initial values to be <span class="pre">number</span>.
</p>
<p>
You might be surprised at multiple definition of member functions: one takes no parameters and the others take parameters.  They are overloaded by their types of parameters.  When you construct the class with <span class="pre">new Point()</span>, the first constructor, which takes no parameters, is called. The second with two parameters will be called on <span class="pre">new Point(2, 3)</span> and the third with one parameter will be called as a copy constructor. Other forms of construction, e.g. <span class="pre">new Point(42)</span> or <span class="pre">new Point("foo", "bar")</span> will cause compilation errors of mismatching signatures. The <span class="pre">Point#set()</span> functions are also overloaded and the compiler know how to call the correct one.
</p>

<h2 id="static-types">Static Types</h2>
<p>
Basic type concept will be described in this section.  Primitive types, object types, variant type, and MayBeUndefined types exist in JSX.
</p>
<p>
Primitive types, e.g. <span class="pre">string</span>, <span class="pre">boolean</span>, or <span class="pre">number</span> are non-nullable, immutable types.
</p>
<pre>
var s : string = "hello";
var n : number = 42;
var b : boolean = true;
</pre>
<p>
Object types, e.g. <span class="pre">string[]</span> (array of string), functions or <span class="pre">Date</span>, are nullable, mutable types.</p>
<pre>
var d : Date = new Date(); // Date
var f : function():void = function() : void { log "Hi!"; };
var a : string[] = ["foo"]; // the same as Array.&lt;string&gt;
</pre>
<p>
Variant type, which means "no static type information," is used for interacting with existing JavaScript APIs.  Some JavaScript libraries may return a variant value, which type cannot be determined at compile time.  All you can do on variant values is to check equality of a variant value to another variant value. You have to cast it to another type before doing anything else on the value.
</p>
<p>
MayBeUndefined type is a meta type which indicates a value may be undefined.  For example, the return type of <span class="pre">Array.&lt;string&gt;#shift()</span> is <span class="pre">MayBeUndefined.&lt;string&gt;</span>. When you use a MayBeUndefined value, you have to make sure of the value is not undefined.</p>
<pre>
function shiftOrReturnEmptyString(args : string[]) : string {
    if (args.length > 0)
        return args.shift();
    else
        return "";
}
</pre>
<div class="note">
When the source code is compiled in debug mode (which is the default), the compiler will insert run-time type-checking code.  An exception will be raised (or the debugger will be activated) when misuse of an undefined value as actual value is detected.  Run-time type checks can be omitted by compiling the source code with the <span class="pre">--release</span> option.
</div>

<h3 id="classes-and-interfaces"></h3>
<p>
As we saw, JSX is a class-based object-oriented language, whose class model is similar to Java. That is, a class may extend another class and implement multiple interfaces. When a class extends another class, it inherits all the members from the base class. Interfaces are used for inter-class connection. A function can use an interface as a parameter type and you can pass any class which implements the interface. The class is interested only in the interface; it needs not to know the implementation details. See the following example.
</p>
<pre>
interface Flyable {
    abstract function fly() : void;
}

abstract class Animal {
    function eat() : void {
      log "An animal is eating!";
    }
}

class Bat extends Animal implements Flyable {
    override function fly() : void {
        log "A bat is flying!";
    }
}

abstract class Insect {
}

class Bee extends Insect implements Flyable {
    override function fly() : void {
        log "A bee is flying!";
    }
}

class _Main {

    static function main(args : string[]) : void {
        // fo bar
        var bat = new Bat();

        var animal : Animal = bat; // OK. A bat is an animal.
        animal.eat();

        var flyable : Flyable = bat; // OK. A bat can fly
        flyable.fly();

        // for Bee
        var bee = new Bee();

        flyable = bee; // A bee is also flyable
        flyable.fly();
    }
}
</pre>
<p>
The Bat class extnds the Animal class, so it inherits <code>Animal#eat()</code> member function and it can be assigned to a variable typed to Animal, and it also implements the Flyable interface, so it overrides <code>Flyable#fly()</code> member function and it can be assigned to a variable typed Flyable. There's also another flyable class, Bee. You can deal with both classes as a flyable being, even if the organ of a bee is completely different to that of a bat.
</p>

<div class="note">
If you overrides a member function, you have to use the <em>override</em> keyword. Otherwise the compiler will report errors. In other words, you are saved from unexpected interface changes in the base classes which cause compilation errors in derived classes instead of undesirable runtime errors.
</div>

<h3 id="function-and-closures"></h3>

<p>
Functions is a first-class object and they have static types. You can declare a variable with a function type like <code>var f : function(arg : number) : number</code>, which takes a number as an argument and returns another number (or, just returns the same value as the argument; but it's not important here). The <code>f</code> can be called as <code>f(42)</code> from which you will get a number value. There are anonumous functions and closures, which cah be assigned to a variable typed functions in that way. Function types and closures are typically used to implement event listeners, which are popular in GUI programming.
</p>
<p>
Functions and closures are similar to JavaScript except for what <code>this</code> points: it refers the receiver of the member function. See the folloging example.
</p>
<pre>
class _Main {
    var foo = 42;

    function constructor() {
        var f = function() : void {
            log this.foo;
        };

        f(); // says 42
    }

    static function main(args : string[]) : void {
        var o = new _Main();
    }
}
</pre>

<h2 id="modules">Modules</h2>

<p>
JSX has a module system. You can reuse JSX class libraries by the <span class="pre">import</span> statement. For example, the following program uses <span class="pre">timer.jsx</pre> module, which exports the <span class="pre">Timer</span> class.
</p>
<pre>
import "timer.jsx";

class _Main {

    static function main(args : string[]) : void {
        Timer.setTimeout(function() : void {
            log "Hello, world!";
        }, 1000);
    }

}
</pre>
<p>
A module may export multiple classes, but you can specify what modules you import or name a namespace which the module is imported into.
</p>

<h2 id="on-web-browsers">Interface to Web Browsers</h2>

<p>
The <span class="pre">js/web.jsx</span> module provides the interface to web browser APIs, e.g. the <span class="pre">window</pan> object and DOM APIs.  The example below shows how to insert a text node into an HTML.
</p>
<pre>
// hello.jsx
import "js/web.jsx";

class _Main {

    static function say() : void {
        var text = dom.window.document.createTextNode("Hello, world!");
        dom.getElementById("hello").appendChild(text);
    }

}
</pre>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;Hello, world!&lt;/title&gt;
    &lt;script src="hello.jsx.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        window.addEventListener("load", function(e) {
            JSX.require("hello.jsx").Hello.say$();
        });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;p id="hello"&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
Once you compile <span class="pre">hello.jsx</span> by the following command, then you can access the HTML and you will see it saying "Hello, world!."
</p>
<pre>
$ bin/jsx --output hello.jsx.js hello.jsx
</pre>

</div>
<div id="footer">
Copyright &copy; 2012 <a href="http://dena.jp/intl/">DeNA Co., Ltd.</a>
</div>
</center>
</body>
</html>
